#!/usr/bin/env python3
import argparse
import sys
import re
import random
import subprocess
import os
from typing import List, Tuple

# Configuration
CLI_IMAGE = "kobara-cli"
NETWORK = "kote_kobara-net"

def is_docker_available() -> bool:
    """Check if Docker is available and running."""
    try:
        subprocess.run(["docker", "info"], capture_output=True, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def ensure_docker_image():
    """Ensure the CLI Docker image exists, build if it doesn't."""
    result = subprocess.run(
        ["docker", "images", "-q", CLI_IMAGE],
        capture_output=True,
        text=True
    )
    if not result.stdout.strip():
        print("Building CLI image...")
        subprocess.run(
            ["docker", "build", "-t", CLI_IMAGE, "-f", "kobara-cli/Dockerfile", "."],
            check=True
        )

def generate_order_id() -> int:
    """Generate a simple numeric ID."""
    return random.randint(1, 1000000)

def parse_order(order_str: str) -> Tuple[str, float, float]:
    """Parse order strings like '100@10' or '100'."""
    if '@' in order_str:
        quantity, price = order_str.split('@')
        return ('limit', float(price), float(quantity))
    else:
        return ('market', 0.0, float(order_str))

def parse_compound_orders(args: List[str]) -> List[dict]:
    """Parse a sequence of buy/sell orders."""
    orders = []
    current_side = None

    i = 0
    while i < len(args):
        arg = args[i].lower()

        if arg in ['buy', 'sell']:
            current_side = 'bid' if arg == 'buy' else 'ask'
            i += 1
            continue

        if not current_side:
            raise ValueError("Must specify buy or sell before quantities")

        try:
            order_type, price, quantity = parse_order(args[i])
            orders.append({
                'id': generate_order_id(),
                'side': current_side,
                'type': order_type,
                'price': price,
                'quantity': quantity
            })
        except ValueError as e:
            raise ValueError(f"Invalid order format: {args[i]}")

        i += 1

    return orders

def execute_cli_command(cmd_args: List[str], use_docker: bool = False):
    """Execute a CLI command either locally or via Docker."""
    if use_docker:
        ensure_docker_image()
        full_cmd = [
            "docker", "run", "--rm",
            "--network", NETWORK,
            "-e", "kobara_OB_HOST=orderbook",
            "-e", "kobara_OB_PORT=50051",
            CLI_IMAGE
        ] + cmd_args
    else:
        full_cmd = ["./cli.py"] + cmd_args

    try:
        result = subprocess.run(full_cmd, capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        if e.stderr:
            print(f"Error: {e.stderr}", file=sys.stderr)
        sys.exit(1)

def execute_orders(orders: List[dict], use_docker: bool = False):
    """Execute orders using the underlying CLI."""
    for order in orders:
        if order['type'] == 'market':
            cmd = [
                "place",
                str(order['id']),  # Convert ID to string
                "0",  # price for market orders
                str(order['quantity']),
                order['side'],
                "market"
            ]
        else:
            cmd = [
                "place",
                str(order['id']),  # Convert ID to string
                str(order['price']),
                str(order['quantity']),
                order['side'],
                "limit"
            ]

        output = execute_cli_command(cmd, use_docker)
        order_desc = (f"{order['quantity']} @ {order['price']}"
                     if order['type'] == 'limit'
                     else str(order['quantity']))
        print(f"Placed {order['side']} order: {order_desc} (ID: {order['id']})")
        if output and output.strip():
            print(output)

def show_book(depth: int, use_docker: bool = False):
    """Show the order book."""
    output = execute_cli_command(["book", str(depth)], use_docker)
    print(output, end='')

def show_trades(limit: int, use_docker: bool = False):
    """Show recent trades."""
    output = execute_cli_command(["trades", str(limit)], use_docker)
    print(output, end='')

def main():
    parser = argparse.ArgumentParser(description='kobaraVM Order Book Interface')

    # Add global options
    parser.add_argument('--docker', action='store_true', help='Use Docker for execution')
    parser.add_argument('--local', action='store_true', help='Force local execution')

    subparsers = parser.add_subparsers(dest='command')

    # Book command
    book_parser = subparsers.add_parser('book', help='Show order book')
    book_parser.add_argument('depth', type=int, nargs='?', default=10)

    # Trades command
    trades_parser = subparsers.add_parser('trades', help='Show recent trades')
    trades_parser.add_argument('limit', type=int, nargs='?', default=10, help='Number of recent trades to show')

    # Orders command
    orders_parser = subparsers.add_parser('orders', help='Place multiple orders')
    orders_parser.add_argument('orders', nargs='+', help='Orders in format: buy/sell QUANTITY[@PRICE] ...')

    # Convenience commands
    buy_parser = subparsers.add_parser('buy', help='Place buy orders')
    buy_parser.add_argument('orders', nargs='+', help='Orders in format: QUANTITY[@PRICE] ...')

    sell_parser = subparsers.add_parser('sell', help='Place sell orders')
    sell_parser.add_argument('orders', nargs='+', help='Orders in format: QUANTITY[@PRICE] ...')

    args = parser.parse_args()

    # Determine execution mode
    use_docker = False
    if not args.local and (args.docker or is_docker_available()):
        use_docker = True

    try:
        if args.command == 'book':
            show_book(args.depth, use_docker)
        elif args.command == 'trades':
            show_trades(args.limit, use_docker)
        elif args.command == 'orders':
            orders = parse_compound_orders(args.orders)
            execute_orders(orders, use_docker)
        elif args.command in ['buy', 'sell']:
            # Prepend the side to the orders
            full_args = [args.command] + args.orders
            orders = parse_compound_orders(full_args)
            execute_orders(orders, use_docker)
        else:
            parser.print_help()

    except ValueError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
